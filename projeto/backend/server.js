require("dotenv").config();

const express = require("express");
const cors = require("cors");
const fs = require("fs");
const path = require("path");
const http = require("http");
const socketIo = require("socket.io");
const jwt = require("jsonwebtoken");

/**
 * Configura√ß√£o e inicializa√ß√£o do servidor Express
 * 
 * Este servidor fornece uma API REST completa para a plataforma de forma√ß√£o,
 * incluindo funcionalidades de WebSocket para comunica√ß√£o em tempo real,
 * gest√£o de uploads de ficheiros e autentica√ß√£o baseada em JWT.
 */

// Banner de inicializa√ß√£o
console.log("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
console.log("‚ïë                    üöÄ PLATAFORMA DE FORMA√á√ÉO - SERVER STARTUP                ‚ïë");
console.log("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
console.log("");

// Informa√ß√µes do ambiente
console.log("üìã CONFIGURA√á√ÉO DO SERVIDOR:");
console.log(`   ‚Ä¢ Ambiente: ${process.env.NODE_ENV || 'development'}`);
console.log(`   ‚Ä¢ Porta: ${process.env.PORT || 4000}`);
console.log(`   ‚Ä¢ Host: ${process.env.HOST || '0.0.0.0'}`);
console.log(`   ‚Ä¢ Pasta de uploads: ${process.env.CAMINHO_PASTA_UPLOADS || 'uploads'}`);
console.log(`   ‚Ä¢ JWT configurado: ${process.env.JWT_SECRET ? '‚úÖ' : '‚ùå'}`);
console.log(`   ‚Ä¢ Base de dados configurada: ${(process.env.DB_HOST || process.env.DATABASE_URL) ? '‚úÖ' : '‚ùå'}`);
console.log(`   ‚Ä¢ Email configurado: ${(process.env.EMAIL_USER && process.env.EMAIL_PASS) ? '‚úÖ' : '‚ùå'}`);
console.log("");

// Configura√ß√£o base do servidor Express e HTTP
const app = express();
const server = http.createServer(app);

// Garantir configura√ß√£o da pasta de uploads
if (!process.env.CAMINHO_PASTA_UPLOADS) {
  process.env.CAMINHO_PASTA_UPLOADS = 'uploads';
}

// Configura√ß√£o de middleware para uploads e garantir que as pastas existem
console.log("üìÅ A configurar middleware de uploads...");
const uploadUtils = require("./src/middleware/upload");
uploadUtils.ensureBaseDirs();
console.log("‚úÖ Middleware de uploads configurado");
console.log("");

/**
 * Configura√ß√£o do Socket.IO para comunica√ß√£o em tempo real
 * 
 * Funcionalidades suportadas:
 * - Notifica√ß√µes instant√¢neas para utilizadores
 * - Chat em tempo real para discuss√µes de cursos
 * - Atualiza√ß√µes autom√°ticas de estado de inscri√ß√µes
 * - Notifica√ß√µes de novos conte√∫dos e avalia√ß√µes
 */
console.log("üîå A configurar WebSocket (Socket.IO)...");
const io = socketIo(server, {
  cors: {
    origin: true,
    credentials: true,
    methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    allowedHeaders: ["Content-Type", "Authorization"],
  },
  path: "/socket.io",
});

/**
 * Middleware de autentica√ß√£o para liga√ß√µes WebSocket
 * Valida o token JWT antes de permitir liga√ß√£o via socket
 * 
 * @param {Socket} socket - Inst√¢ncia do socket do cliente
 * @param {Function} next - Callback para continuar ou rejeitar a liga√ß√£o
 */
io.use((socket, next) => {
  const token = socket.handshake.query.token;
  if (!token) {
    return next(new Error("Autentica√ß√£o necess√°ria"));
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    socket.user = decoded;
    next();
  } catch (error) {
    next(new Error("Token inv√°lido"));
  }
});

/**
 * Gest√£o principal de liga√ß√µes WebSocket
 * 
 * Organiza utilizadores em salas espec√≠ficas para:
 * - Notifica√ß√µes pessoais (user_${userId})
 * - Discuss√µes de t√≥picos (topico_${topicoId})
 * - F√≥runs tem√°ticos (tema_${temaId})
 */
io.on("connection", (socket) => {
  const userId = socket.user ? socket.user.id_utilizador || socket.user.id : 'an√≥nimo';

  // Adicionar utilizador √† sua sala pessoal para notifica√ß√µes dirigidas
  if (userId !== 'an√≥nimo') {
    socket.join(`user_${userId}`);
    socket.emit('connection_success', {
      message: 'Ligado com sucesso ao sistema de notifica√ß√µes',
      userId: userId,
      timestamp: new Date()
    });
  }

  // Gest√£o de salas de t√≥picos para discuss√µes de cursos
  socket.on("joinTopic", (topicoId) => {
    if (!topicoId) return;
    socket.join(`topico_${topicoId}`);
    socket.emit('topic_joined', {
      topicoId: topicoId,
      message: `Juntaste-te ao t√≥pico ${topicoId}`
    });
  });

  socket.on("leaveTopic", (topicoId) => {
    if (!topicoId) return;
    socket.leave(`topico_${topicoId}`);
    socket.emit('topic_left', {
      topicoId: topicoId,
      message: `Sa√≠ste do t√≥pico ${topicoId}`
    });
  });

  // Gest√£o de salas de temas do f√≥rum geral
  socket.on("joinTema", (temaId) => {
    if (!temaId) return;
    socket.join(`tema_${temaId}`);
    socket.emit('tema_joined', {
      temaId: temaId,
      message: `Juntaste-te ao tema ${temaId}`
    });
  });

  socket.on("leaveTema", (temaId) => {
    if (!temaId) return;
    socket.leave(`tema_${temaId}`);
    socket.emit('tema_left', {
      temaId: temaId,
      message: `Sa√≠ste do tema ${temaId}`
    });
  });

  // Teste de conectividade e diagn√≥stico
  socket.on("ping", () => {
    socket.emit("pong", { 
      message: "Liga√ß√£o WebSocket activa e funcional",
      userId: userId,
      timestamp: new Date(),
      responseTime: Date.now()
    });
  });

  // Sistema de teste para notifica√ß√µes
  socket.on("test_notification", (data) => {
    socket.emit("nova_notificacao", {
      titulo: "üß™ Teste de Notifica√ß√£o",
      mensagem: "Esta √© uma notifica√ß√£o de teste. O sistema est√° a funcionar correctamente!",
      tipo: "teste",
      data: new Date(),
      isTest: true
    });
  });

  // Gest√£o autom√°tica de desconex√£o (limpeza autom√°tica de salas)
  socket.on("disconnect", (reason) => {
    // Socket.IO limpa automaticamente as salas na desconex√£o
  });

  socket.on("error", (error) => {
    // Log apenas essencial para diagn√≥stico
  });
});

console.log("‚úÖ WebSocket configurado com autentica√ß√£o JWT");
console.log("");

/**
 * Configura√ß√£o CORS permissiva para desenvolvimento
 * Em produ√ß√£o, deve ser restringida a dom√≠nios espec√≠ficos
 */
console.log("üåê A configurar CORS...");
app.use(cors({
  origin: function (origin, callback) {
    callback(null, true);
  },
  credentials: true,
  methods: ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
  allowedHeaders: ["Content-Type", "Authorization"],
}));

app.use(express.json());

/**
 * Middleware cr√≠tico: disponibilizar inst√¢ncia Socket.IO em todas as rotas
 * Permite que qualquer controlador envie notifica√ß√µes em tempo real
 */
app.use((req, res, next) => {
  req.io = io;
  next();
});

// Configura√ß√£o para suporte a ficheiros grandes (uploads de v√≠deos/documentos)
app.use(express.json({ limit: '15GB' }));
app.use(express.urlencoded({ extended: true, limit: '15GB' }));
server.timeout = 3600000; // Timeout de 1 hora para uploads grandes

console.log("‚úÖ CORS e middleware configurados");
console.log("‚úÖ Suporte para uploads grandes ativado (at√© 15GB)");
console.log("");

/**
 * Carregamento din√¢mico e seguro de rotas
 * 
 * Funcionalidades de seguran√ßa:
 * - Verifica√ß√£o de exist√™ncia de ficheiros
 * - Valida√ß√£o de rotas funcionais
 * - Cria√ß√£o de fallbacks para servi√ßos indispon√≠veis
 * - Limpeza de cache para hot-reload em desenvolvimento
 * 
 * @param {string} caminho - Caminho para o ficheiro da rota
 * @param {string} prefixo - Prefixo URL da rota na API
 * @returns {object} - Resultado do carregamento com detalhes
 */
function carregarRota(caminho, prefixo) {
  try {
    const rotaPath = path.resolve(caminho);

    // Verificar exist√™ncia do ficheiro da rota
    if (!fs.existsSync(`${rotaPath}.js`)) {
      console.log(`‚ùå Rota n√£o encontrada: ${prefixo} (${caminho}.js)`);
      // Criar rota de fallback para servi√ßo indispon√≠vel
      app.use(prefixo, (req, res) =>
        res.status(503).json({ 
          message: "Servi√ßo temporariamente indispon√≠vel",
          service: prefixo 
        })
      );
      return { sucesso: false, erro: "Ficheiro n√£o encontrado" };
    }

    // Limpar cache para permitir hot-reload em desenvolvimento
    delete require.cache[require.resolve(rotaPath)];
    const rota = require(rotaPath);
    
    // Validar se √© uma rota v√°lida do Express
    if (!rota || typeof rota !== "function") {
      console.log(`‚ùå Rota mal configurada: ${prefixo} (n√£o √© uma fun√ß√£o v√°lida)`);
      app.use(prefixo, (req, res) =>
        res.status(503).json({ 
          message: "Rota mal configurada",
          service: prefixo 
        })
      );
      return { sucesso: false, erro: "Rota inv√°lida" };
    }

    // Registar rota funcional no Express
    app.use(prefixo, rota);
    console.log(`‚úÖ Rota carregada: ${prefixo}`);
    return { sucesso: true };
    
  } catch (error) {
    console.log(`‚ùå Erro ao carregar rota: ${prefixo} - ${error.message}`);
    app.use(prefixo, (req, res) =>
      res.status(503).json({ 
        message: "Erro ao carregar rota",
        service: prefixo,
        error: process.env.NODE_ENV === 'development' ? error.message : undefined
      })
    );
    return { sucesso: false, erro: error.message };
  }
}

/**
 * Defini√ß√£o de todas as rotas do sistema
 * Organizadas por √°rea de responsabilidade e funcionalidade
 */
const rotas = [
  // Painel de controlo e estat√≠sticas administrativas
  { caminho: "./src/routes/dashboard/dashboard_route", prefixo: "/api/dashboard" },

  // Sistema de autentica√ß√£o e gest√£o de utilizadores
  { caminho: "./src/routes/users/auth_route", prefixo: "/api/auth" },
  { caminho: "./src/routes/users/users_route", prefixo: "/api/users" },
  { caminho: "./src/routes/users/areas_route", prefixo: "/api/areas-utilizador" },
  { caminho: "./src/routes/users/formadores_route", prefixo: "/api/formadores" },
  { caminho: "./src/routes/users/presencas_route", prefixo: "/api/presencas" },
  { caminho: "./src/routes/users/Percurso_Formandos_routes", prefixo: "/api/percurso-formandos" },

  // Sistema de cursos com notifica√ß√µes em tempo real
  { caminho: "./src/routes/cursos/curso_categorias_route", prefixo: "/api/categorias" },
  { caminho: "./src/routes/areas/areas_route", prefixo: "/api/areas" },
  { caminho: "./src/routes/cursos/cursos_route", prefixo: "/api/cursos" },
  { caminho: "./src/routes/cursos/associar_cursos_route", prefixo: "/api/associar-cursos" },
  { caminho: "./src/routes/cursos/curso_topicos_route", prefixo: "/api/topicos-curso" },
  { caminho: "./src/routes/cursos/curso_pastas_route", prefixo: "/api/pastas-curso" },
  { caminho: "./src/routes/cursos/curso_conteudos_route", prefixo: "/api/conteudos-curso" },
  { caminho: "./src/routes/cursos/curso_inscricoes_route", prefixo: "/api/inscricoes" },
  { caminho: "./src/routes/cursos/tipos_conteudo_route", prefixo: "/api/tipos-conteudo" },
  { caminho: "./src/routes/quiz/quiz_route", prefixo: "/api/quiz" },

  // Sistema de trabalhos e avalia√ß√µes
  { caminho: "./src/routes/trabalhos/trabalhos_route", prefixo: "/api/trabalhos" },
  { caminho: "./src/routes/avaliacoes/submissoes_route", prefixo: "/api/avaliacoes/submissoes" },
  { caminho: "./src/routes/avaliacoes/avaliar_submissoes_routes", prefixo: "/api/avaliar" },
  { caminho: "./src/routes/avaliacoes/avaliacoes_routes", prefixo: "/api/avaliacoes" },

  // Chat, f√≥runs e comunica√ß√£o em tempo real
  { caminho: "./src/routes/ocorrencias/ocorrencias_route", prefixo: "/api/ocorrencias" },
  { caminho: "./src/routes/chat/chat_routes", prefixo: "/api/chat" },
  { caminho: "./src/routes/chat/Topico_area_routes", prefixo: "/api/topicos-area" },
  { caminho: "./src/routes/chat/Topicos_Chat_routes", prefixo: "/api/forum" },
  { caminho: "./src/routes/chat/Forum_Tema_routes", prefixo: "/api/forum-tema" },
  { caminho: "./src/routes/chat/comentarios_routes", prefixo: "/api/comentarios" },
  { caminho: "./src/routes/chat/denuncias_routes", prefixo: "/api/denuncias" },

  // Servi√ßos especializados e integra√ß√µes
  { caminho: "./src/routes/certificados/certificado_routes", prefixo: "/api/certificados" },
  { caminho: "./src/routes/mailing/mailing_route", prefixo: "/api/mailing" },
  { caminho: "./src/routes/notificacoes/notificacoes_route", prefixo: "/api/notificacoes" },
];

// Carregar associa√ß√µes da base de dados antes de inicializar rotas
console.log("üîó A carregar associa√ß√µes da base de dados...");
try {
  require("./src/database/associations");
  console.log("‚úÖ Associa√ß√µes da base de dados carregadas com sucesso");
} catch (error) {
  console.log(`‚ùå Erro ao carregar associa√ß√µes: ${error.message}`);
}
console.log("");

// Processar carregamento de todas as rotas do sistema
console.log("üõ£Ô∏è  A CARREGAR ROTAS DO SISTEMA:");
console.log("‚îÄ".repeat(80));

const resultadosRotas = rotas.map(({ caminho, prefixo }) => ({
  prefixo,
  resultado: carregarRota(caminho, prefixo)
}));

const rotasCarregadas = resultadosRotas.filter(r => r.resultado.sucesso);
const rotasFalhadas = resultadosRotas.filter(r => !r.resultado.sucesso);

console.log("");
console.log("üìä RESUMO DO CARREGAMENTO DE ROTAS:");
console.log(`   ‚Ä¢ Total de rotas: ${rotas.length}`);
console.log(`   ‚Ä¢ Carregadas com sucesso: ${rotasCarregadas.length}`);
console.log(`   ‚Ä¢ Falhadas: ${rotasFalhadas.length}`);
console.log(`   ‚Ä¢ Taxa de sucesso: ${((rotasCarregadas.length / rotas.length) * 100).toFixed(1)}%`);

if (rotasFalhadas.length > 0) {
  console.log("");
  console.log("‚ö†Ô∏è  ROTAS COM PROBLEMAS:");
  rotasFalhadas.forEach(({ prefixo, resultado }) => {
    console.log(`   ‚Ä¢ ${prefixo}: ${resultado.erro}`);
  });
}

console.log("");

// Configura√ß√£o de ficheiros est√°ticos
console.log("üìÅ A configurar servir de ficheiros est√°ticos...");
console.log(`   ‚Ä¢ Pasta de uploads: /${process.env.CAMINHO_PASTA_UPLOADS}`);
console.log(`   ‚Ä¢ API uploads: /api/uploads`);

// Servir ficheiros est√°ticos de uploads (imagens, documentos, v√≠deos)
app.use("/uploads", express.static(path.join(process.cwd(), process.env.CAMINHO_PASTA_UPLOADS)));
app.use("/api/uploads", express.static(path.join(process.cwd(), process.env.CAMINHO_PASTA_UPLOADS)));

console.log("‚úÖ Ficheiros est√°ticos configurados");
console.log("");

/**
 * Rota principal da API com informa√ß√µes de estado e diagn√≥stico
 */
app.get("/api", (req, res) => {
  const uptimeSeconds = process.uptime();
  const uptimeFormatted = `${Math.floor(uptimeSeconds / 3600)}h ${Math.floor((uptimeSeconds % 3600) / 60)}m ${Math.floor(uptimeSeconds % 60)}s`;
  
  res.json({
    message: "üöÄ API da Plataforma de Forma√ß√£o est√° a funcionar!",
    version: "1.0.0",
    status: "operational",
    timestamp: new Date().toISOString(),
    uptime: uptimeFormatted,
    rotas_carregadas: rotasCarregadas.length,
    total_rotas: rotas.length,
    taxa_sucesso_rotas: `${((rotasCarregadas.length / rotas.length) * 100).toFixed(1)}%`,
    websocket_ativo: true,
    websocket_ligacoes: io.engine.clientsCount,
    upload_dir: process.env.CAMINHO_PASTA_UPLOADS,
    node_env: process.env.NODE_ENV || 'development'
  });
});

/**
 * Rota de diagn√≥stico das vari√°veis de ambiente
 * √ötil para verificar configura√ß√£o em diferentes ambientes
 */
app.get("/api/debug/env", (req, res) => {
  res.json({
    NODE_ENV: process.env.NODE_ENV || 'development',
    PORT: process.env.PORT || 'n√£o definida',
    JWT_SECRET_EXISTS: !!process.env.JWT_SECRET,
    DB_CONFIG_EXISTS: !!(process.env.DB_HOST || process.env.DATABASE_URL),
    EMAIL_CONFIG_EXISTS: !!(process.env.EMAIL_USER && process.env.EMAIL_PASS),
    CAMINHO_PASTA_UPLOADS: process.env.CAMINHO_PASTA_UPLOADS,
    FRONTEND_URL: process.env.FRONTEND_URL || 'n√£o definida',
    WEBSOCKET_READY: true,
    WEBSOCKET_CORS_CONFIGURED: true,
    timestamp: new Date().toISOString()
  });
});

/**
 * Diagn√≥stico do sistema WebSocket
 * Fornece estat√≠sticas de liga√ß√µes e salas activas
 */
app.get("/api/test/websocket", (req, res) => {
  const connectionsCount = io.engine.clientsCount;
  const rooms = Array.from(io.sockets.adapter.rooms.keys());
  const userRooms = rooms.filter(room => room.startsWith('user_'));
  const topicRooms = rooms.filter(room => room.startsWith('topico_'));
  const themeRooms = rooms.filter(room => room.startsWith('tema_'));
  
  res.json({
    message: "üîå Sistema WebSocket est√° operacional",
    status: "active",
    conexoes_ativas: connectionsCount,
    estatisticas_salas: {
      total: rooms.length,
      utilizadores: userRooms.length,
      topicos: topicRooms.length,
      temas: themeRooms.length
    },
    timestamp: new Date().toISOString(),
    test_endpoint: "/api/test/websocket/send"
  });
});

/**
 * Endpoint para testar envio de notifica√ß√µes WebSocket
 * Permite verificar se as notifica√ß√µes chegam aos utilizadores
 */
app.post("/api/test/websocket/send", (req, res) => {
  const { userId, message } = req.body;
  
  if (!userId) {
    return res.status(400).json({ error: "userId √© obrigat√≥rio" });
  }
  
  const testMessage = message || "Esta √© uma notifica√ß√£o de teste do sistema!";
  
  // Enviar notifica√ß√£o de teste para o utilizador espec√≠fico
  io.to(`user_${userId}`).emit('nova_notificacao', {
    titulo: "üß™ Teste de Notifica√ß√£o",
    mensagem: testMessage,
    tipo: "teste",
    data: new Date(),
    isTest: true
  });
  
  res.json({
    message: `Notifica√ß√£o de teste enviada para utilizador ${userId}`,
    timestamp: new Date().toISOString()
  });
});

// Inicializa√ß√£o de agendamentos autom√°ticos (se dispon√≠vel)
console.log("‚è∞ A verificar agendamentos autom√°ticos...");
try {
  const schedPath = path.join(__dirname, "src/utils/schedulers.js");
  if (fs.existsSync(schedPath)) {
    const { iniciarAgendamentos } = require(schedPath);
    iniciarAgendamentos();
    console.log("‚úÖ Agendamentos autom√°ticos iniciados");
  } else {
    console.log("‚ÑπÔ∏è  Ficheiro de agendamentos n√£o encontrado - a continuar sem agendamentos");
  }
} catch (error) {
  console.log(`‚ùå Erro ao iniciar agendamentos: ${error.message}`);
}
console.log("");

/**
 * Servir aplica√ß√£o React compilada em produ√ß√£o
 * Suporte completo para Single Page Application com client-side routing
 */
const clienteBuildPath = path.join(__dirname, "../front/build");

console.log("üåê A verificar frontend React...");
if (fs.existsSync(clienteBuildPath)) {
  console.log(`‚úÖ Frontend encontrado em: ${clienteBuildPath}`);
  console.log("üîß A configurar routing SPA...");
  
  app.use(express.static(clienteBuildPath));

  // Rota catch-all para SPA routing - todas as rotas n√£o-API servem o React
  app.get("*", (req, res) => {
    // Excluir rotas da API e uploads do SPA routing
    if (req.path.startsWith("/api") || req.path.startsWith("/uploads")) {
      return res.status(404).json({ 
        message: "Endpoint n√£o encontrado",
        path: req.path,
        method: req.method
      });
    }
    
    res.sendFile(path.join(clienteBuildPath, "index.html"));
  });
  
  console.log("‚úÖ Frontend React configurado com SPA routing");
} else {
  console.log("‚ö†Ô∏è  Frontend React n√£o encontrado - apenas API dispon√≠vel");
  console.log(`   Procurado em: ${clienteBuildPath}`);
  
  // Rota de fallback quando n√£o h√° frontend compilado
  app.get("*", (req, res) => {
    if (req.path.startsWith("/api") || req.path.startsWith("/uploads")) {
      return res.status(404).json({ message: "Endpoint n√£o encontrado" });
    }
    
    res.json({
      message: "üöÄ API da Plataforma de Forma√ß√£o",
      info: "Frontend n√£o dispon√≠vel. Acede √† documenta√ß√£o da API em /api",
      endpoints: [
        "/api - Informa√ß√µes da API",
        "/api/debug/env - Diagn√≥stico do ambiente",
        "/api/test/websocket - Teste do WebSocket"
      ]
    });
  });
}
console.log("");

/**
 * Middleware global de tratamento de erros
 * Captura todos os erros n√£o tratados e fornece respostas consistentes
 */
app.use((err, req, res, next) => {
  res.status(500).json({ 
    message: "Erro interno do servidor",
    timestamp: new Date().toISOString(),
    requestId: req.headers['x-request-id'] || 'unknown',
    error: process.env.NODE_ENV === 'development' ? err.message : undefined
  });
});

/**
 * Handler para rotas n√£o encontradas (404)
 * Fornece informa√ß√µes √∫teis sobre o erro de rota
 */
app.use((req, res) => {
  res.status(404).json({
    message: "Rota n√£o encontrada",
    path: req.url,
    method: req.method,
    timestamp: new Date().toISOString(),
    suggestion: "Verifica a documenta√ß√£o da API em /api"
  });
});

/**
 * Inicializa√ß√£o do servidor HTTP com Socket.IO
 */
const PORT = process.env.PORT || 4000;
const HOST = process.env.HOST || '0.0.0.0';

console.log("üöÄ A INICIAR SERVIDOR...");
console.log("‚îÄ".repeat(80));

server.listen(PORT, HOST, () => {
  const currentTime = new Date().toLocaleString('pt-PT', {
    timeZone: 'Europe/Lisbon',
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
  });

  console.log("");
  console.log("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
  console.log("‚ïë                          ‚úÖ SERVIDOR INICIADO COM SUCESSO                    ‚ïë");
  console.log("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
  console.log("");
  console.log("üåê INFORMA√á√ïES DE ACESSO:");
  console.log(`   ‚Ä¢ URL Local: http://localhost:${PORT}`);
  console.log(`   ‚Ä¢ URL Rede: http://${HOST}:${PORT}`);
  console.log(`   ‚Ä¢ API Docs: http://localhost:${PORT}/api`);
  console.log(`   ‚Ä¢ WebSocket: ws://localhost:${PORT}/socket.io`);
  console.log("");
  console.log("üìä ESTAT√çSTICAS:");
  console.log(`   ‚Ä¢ Rotas carregadas: ${rotasCarregadas.length}/${rotas.length}`);
  console.log(`   ‚Ä¢ WebSocket ativo: ‚úÖ`);
  console.log(`   ‚Ä¢ Frontend React: ${fs.existsSync(clienteBuildPath) ? '‚úÖ' : '‚ùå'}`);
  console.log(`   ‚Ä¢ Uploads configurados: ‚úÖ`);
  console.log("");
  console.log("üïê INICIADO EM:", currentTime);
  console.log("");
  console.log("üîß ENDPOINTS √öTEIS:");
  console.log("   ‚Ä¢ GET  /api                    - Informa√ß√µes da API");
  console.log("   ‚Ä¢ GET  /api/debug/env          - Diagn√≥stico do ambiente");
  console.log("   ‚Ä¢ GET  /api/test/websocket     - Teste do WebSocket");
  console.log("   ‚Ä¢ POST /api/test/websocket/send - Enviar notifica√ß√£o teste");
  console.log("");
  console.log("üí° NOTA: O servidor est√° pronto para aceitar liga√ß√µes!");
  console.log("‚ïê".repeat(80));
});

/**
 * Gest√£o graceful de shutdown
 * Garante encerramento limpo de liga√ß√µes WebSocket e HTTP
 */
process.on('SIGTERM', () => {
  console.log('\nüõë Sinal SIGTERM recebido. A encerrar servidor graciosamente...');
  server.close(() => {
    console.log('üì° Servidor HTTP encerrado');
    io.close(() => {
      console.log('üîå Liga√ß√µes WebSocket encerradas');
      console.log('‚úÖ Shutdown completo');
      process.exit(0);
    });
  });
});

process.on('SIGINT', () => {
  console.log('\nüõë Sinal SIGINT recebido (Ctrl+C). A encerrar servidor...');
  server.close(() => {
    console.log('‚úÖ Servidor encerrado com sucesso');
    process.exit(0);
  });
});

// Capturar erros cr√≠ticos para evitar crashes inesperados
process.on('uncaughtException', (error) => {
  console.log('üí• Erro cr√≠tico n√£o capturado:', error.message);
  console.log('üîÑ A reiniciar servidor...');
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  console.log('‚ö†Ô∏è  Promise rejeitada n√£o tratada:', reason);
  console.log('üîÑ A reiniciar servidor...');
  process.exit(1);
});