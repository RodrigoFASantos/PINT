require("dotenv").config();

const express = require("express");
const cors = require("cors");
const fs = require("fs");
const path = require("path");
const http = require("http");
const socketIo = require("socket.io");
const jwt = require("jsonwebtoken");

// Configura√ß√£o base do servidor Express e HTTP
const app = express();
const server = http.createServer(app);

// Configurar pasta de uploads predefinida se n√£o estiver especificada
if (!process.env.CAMINHO_PASTA_UPLOADS) {
  process.env.CAMINHO_PASTA_UPLOADS = 'uploads';
}

// Garantir que as pastas de upload existem e configurar middleware
const uploadUtils = require("./src/middleware/upload");
uploadUtils.ensureBaseDirs();

/**
 * Configura√ß√£o do Socket.IO para comunica√ß√£o em tempo real
 * 
 * Permite envio instant√¢neo de notifica√ß√µes e chat entre utilizadores.
 * Configurado com CORS permissivo para desenvolvimento.
 */
const io = socketIo(server, {
  cors: {
    origin: true,
    credentials: true,
    methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    allowedHeaders: ["Content-Type", "Authorization"],
  },
  path: "/socket.io",
});

/**
 * Middleware de autentica√ß√£o para liga√ß√µes WebSocket
 * 
 * Valida o token JWT antes de permitir liga√ß√£o via socket,
 * garantindo que apenas utilizadores autenticados acedem √†s notifica√ß√µes.
 */
io.use((socket, next) => {
  const token = socket.handshake.query.token;
  if (!token) {
    console.warn('‚ö†Ô∏è [WEBSOCKET] Tentativa de liga√ß√£o sem token de autentica√ß√£o');
    return next(new Error("Autentica√ß√£o necess√°ria"));
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    socket.user = decoded;
    console.log(`üîë [WEBSOCKET] Utilizador autenticado: ${decoded.id_utilizador || decoded.id}`);
    next();
  } catch (error) {
    console.error('‚ùå [WEBSOCKET] Token inv√°lido:', error.message);
    next(new Error("Token inv√°lido"));
  }
});

/**
 * Gest√£o principal de liga√ß√µes WebSocket
 * 
 * Quando um utilizador se liga, √© automaticamente adicionado √† sua sala pessoal
 * para receber notifica√ß√µes. Suporta tamb√©m salas de t√≥picos e temas para chat.
 */
io.on("connection", (socket) => {
  const userId = socket.user ? socket.user.id_utilizador || socket.user.id : 'an√≥nimo';
  
  console.log(`‚úÖ [WEBSOCKET] Utilizador ${userId} ligado com sucesso`);

  // Adicionar utilizador √† sua sala pessoal para notifica√ß√µes
  if (userId !== 'an√≥nimo') {
    socket.join(`user_${userId}`);
    console.log(`üîî [WEBSOCKET] Utilizador ${userId} adicionado √† sala de notifica√ß√µes pessoais`);
    
    // Confirmar liga√ß√£o bem-sucedida ao cliente
    socket.emit('connection_success', {
      message: 'Ligado com sucesso ao sistema de notifica√ß√µes',
      userId: userId,
      timestamp: new Date()
    });
  }

  /**
   * Juntar-se a sala de t√≥pico espec√≠fico para discuss√µes
   * Usado para chat em contexto de cursos ou √°reas tem√°ticas
   */
  socket.on("joinTopic", (topicoId) => {
    if (!topicoId) {
      console.warn(`‚ö†Ô∏è [WEBSOCKET] ID de t√≥pico inv√°lido fornecido por ${userId}`);
      return;
    }

    socket.join(`topico_${topicoId}`);
    console.log(`üìö [WEBSOCKET] Utilizador ${userId} juntou-se ao t√≥pico ${topicoId}`);
    
    socket.emit('topic_joined', {
      topicoId: topicoId,
      message: `Juntaste-te ao t√≥pico ${topicoId}`
    });
  });

  /**
   * Sair de sala de t√≥pico
   */
  socket.on("leaveTopic", (topicoId) => {
    if (!topicoId) return;

    socket.leave(`topico_${topicoId}`);
    console.log(`üìö [WEBSOCKET] Utilizador ${userId} saiu do t√≥pico ${topicoId}`);
    
    socket.emit('topic_left', {
      topicoId: topicoId,
      message: `Sa√≠ste do t√≥pico ${topicoId}`
    });
  });

  /**
   * Juntar-se a sala de tema do f√≥rum
   * Para discuss√µes gerais em temas espec√≠ficos do f√≥rum
   */
  socket.on("joinTema", (temaId) => {
    if (!temaId) {
      console.warn(`‚ö†Ô∏è [WEBSOCKET] ID de tema inv√°lido fornecido por ${userId}`);
      return;
    }

    socket.join(`tema_${temaId}`);
    console.log(`üí¨ [WEBSOCKET] Utilizador ${userId} juntou-se ao tema ${temaId}`);
    
    socket.emit('tema_joined', {
      temaId: temaId,
      message: `Juntaste-te ao tema ${temaId}`
    });
  });

  /**
   * Sair de sala de tema do f√≥rum
   */
  socket.on("leaveTema", (temaId) => {
    if (!temaId) return;

    socket.leave(`tema_${temaId}`);
    console.log(`üí¨ [WEBSOCKET] Utilizador ${userId} saiu do tema ${temaId}`);
    
    socket.emit('tema_left', {
      temaId: temaId,
      message: `Sa√≠ste do tema ${temaId}`
    });
  });

  /**
   * Teste de conectividade WebSocket
   * Permite verificar se a liga√ß√£o est√° ativa e funcional
   */
  socket.on("ping", () => {
    const responseTime = Date.now();
    socket.emit("pong", { 
      message: "Liga√ß√£o WebSocket ativa e funcional",
      userId: userId,
      timestamp: new Date(responseTime),
      responseTime: responseTime
    });
    console.log(`üèì [WEBSOCKET] Ping/Pong com utilizador ${userId}`);
  });

  /**
   * Teste de notifica√ß√µes personalizado
   * Permite aos clientes testarem a rece√ß√£o de notifica√ß√µes
   */
  socket.on("test_notification", (data) => {
    console.log(`üß™ [WEBSOCKET] Teste de notifica√ß√£o solicitado por ${userId}`);
    
    socket.emit("nova_notificacao", {
      titulo: "üß™ Teste de Notifica√ß√£o",
      mensagem: "Esta √© uma notifica√ß√£o de teste. O sistema est√° a funcionar corretamente!",
      tipo: "teste",
      data: new Date(),
      isTest: true
    });
  });

  /**
   * Gest√£o de desconex√£o
   * Limpeza autom√°tica quando utilizador sai da aplica√ß√£o
   */
  socket.on("disconnect", (reason) => {
    console.log(`‚ùå [WEBSOCKET] Utilizador ${userId} desligado. Motivo: ${reason}`);
  });

  /**
   * Captura de erros do socket para debugging
   */
  socket.on("error", (error) => {
    console.error(`üí• [WEBSOCKET] Erro no socket do utilizador ${userId}:`, error.message);
  });
});

// Monitoriza√ß√£o peri√≥dica de liga√ß√µes ativas
setInterval(() => {
  const connectedSockets = io.engine.clientsCount;
  if (connectedSockets > 0) {
    console.log(`üìä [WEBSOCKET] ${connectedSockets} liga√ß√µes WebSocket ativas`);
  }
}, 300000); // A cada 5 minutos

/**
 * Configura√ß√£o CORS permissiva para desenvolvimento
 * Em produ√ß√£o deve ser restringida a dom√≠nios espec√≠ficos
 */
app.use(cors({
  origin: function (origin, callback) {
    callback(null, true);
  },
  credentials: true,
  methods: ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
  allowedHeaders: ["Content-Type", "Authorization"],
}));

app.use(express.json());

/**
 * Middleware cr√≠tico: disponibilizar inst√¢ncia Socket.IO em todas as rotas
 * 
 * Permite que qualquer controlador envie notifica√ß√µes em tempo real
 * atrav√©s de req.io. Essencial para o funcionamento das notifica√ß√µes.
 */
app.use((req, res, next) => {
  req.io = io;
  next();
});

// Configura√ß√£o para suporte a ficheiros grandes (at√© 15GB)
app.use(express.json({ limit: '15GB' }));
app.use(express.urlencoded({ extended: true, limit: '15GB' }));
server.timeout = 3600000; // Timeout de 1 hora para uploads grandes

/**
 * Carregamento din√¢mico e seguro de rotas
 * 
 * Carrega cada rota com tratamento de erros e fallbacks para
 * servi√ßos indispon√≠veis.
 */
function carregarRota(caminho, prefixo) {
  try {
    const rotaPath = path.resolve(caminho);

    // Verificar se o ficheiro da rota existe
    if (!fs.existsSync(`${rotaPath}.js`)) {
      console.error(`‚ùå [ROTAS] Ficheiro n√£o encontrado: ${rotaPath}.js`);
      
      // Criar rota de fallback
      app.use(prefixo, (req, res) =>
        res.status(503).json({ 
          message: "Servi√ßo temporariamente indispon√≠vel",
          service: prefixo 
        })
      );
      return false;
    }

    // Limpar cache para permitir hot-reload em desenvolvimento
    delete require.cache[require.resolve(rotaPath)];
    const rota = require(rotaPath);
    
    // Validar se √© uma rota v√°lida do Express
    if (!rota || typeof rota !== "function" || !rota.stack) {
      console.error(`‚ùå [ROTAS] Rota mal formada: ${prefixo}`);
      
      app.use(prefixo, (req, res) =>
        res.status(503).json({ 
          message: "Rota mal configurada",
          service: prefixo 
        })
      );
      return false;
    }

    // Registar rota funcional no Express
    app.use(prefixo, rota);
    console.log(`‚úÖ [ROTAS] Rota carregada com sucesso: ${prefixo}`);
    return true;
    
  } catch (error) {
    console.error(`üí• [ROTAS] Erro ao carregar ${prefixo}:`, error.message);
    
    app.use(prefixo, (req, res) =>
      res.status(503).json({ 
        message: "Erro ao carregar rota",
        service: prefixo,
        error: process.env.NODE_ENV === 'development' ? error.message : undefined
      })
    );
    return false;
  }
}

/**
 * Defini√ß√£o de todas as rotas do sistema
 * Cada entrada representa um m√≥dulo funcional da aplica√ß√£o
 */
const rotas = [
  // Painel de controlo e estat√≠sticas
  { caminho: "./src/routes/dashboard/dashboard_route", prefixo: "/api/dashboard" },

  // Gest√£o de utilizadores e autentica√ß√£o
  { caminho: "./src/routes/users/auth_route", prefixo: "/api/auth" },
  { caminho: "./src/routes/users/users_route", prefixo: "/api/users" },
  { caminho: "./src/routes/users/areas_route", prefixo: "/api/areas" },
  { caminho: "./src/routes/users/formadores_route", prefixo: "/api/formadores" },
  { caminho: "./src/routes/users/presencas_route", prefixo: "/api/presencas" },
  { caminho: "./src/routes/users/Percurso_Formandos_routes", prefixo: "/api/percurso-formandos" },

  // Sistema de cursos com notifica√ß√µes
  { caminho: "./src/routes/cursos/curso_categorias_route", prefixo: "/api/categorias" },
  { caminho: "./src/routes/cursos/cursos_route", prefixo: "/api/cursos" },
  { caminho: "./src/routes/cursos/associar_cursos_route", prefixo: "/api/associar-cursos" },
  { caminho: "./src/routes/cursos/curso_topicos_route", prefixo: "/api/topicos-curso" },
  { caminho: "./src/routes/cursos/curso_pastas_route", prefixo: "/api/pastas-curso" },
  { caminho: "./src/routes/cursos/curso_conteudos_route", prefixo: "/api/conteudos-curso" },
  { caminho: "./src/routes/cursos/curso_inscricoes_route", prefixo: "/api/inscricoes" },
  { caminho: "./src/routes/cursos/tipos_conteudo_route", prefixo: "/api/tipos-conteudo" },
  { caminho: "./src/routes/quiz/quiz_route", prefixo: "/api/quiz" },

  // Sistema de trabalhos e avalia√ß√µes
  { caminho: "./src/routes/trabalhos/trabalhos_route", prefixo: "/api/trabalhos" },
  { caminho: "./src/routes/avaliacoes/submissoes_route", prefixo: "/api/avaliacoes/submissoes" },
  { caminho: "./src/routes/avaliacoes/avaliar_submissoes_routes", prefixo: "/api/avaliar" },
  { caminho: "./src/routes/avaliacoes/avaliacoes_routes", prefixo: "/api/avaliacoes" },

  // Chat, f√≥runs e comunica√ß√£o em tempo real
  { caminho: "./src/routes/ocorrencias/ocorrencias_route", prefixo: "/api/ocorrencias" },
  { caminho: "./src/routes/chat/chat_routes", prefixo: "/api/chat" },
  { caminho: "./src/routes/chat/Topico_area_routes", prefixo: "/api/topicos-area" },
  { caminho: "./src/routes/chat/Topicos_Chat_routes", prefixo: "/api/forum" },
  { caminho: "./src/routes/chat/Forum_Tema_routes", prefixo: "/api/forum-tema" },
  { caminho: "./src/routes/chat/comentarios_routes", prefixo: "/api/comentarios" },
  { caminho: "./src/routes/chat/denuncias_routes", prefixo: "/api/denuncias" },

  // Servi√ßos especializados
  { caminho: "./src/routes/certificados/certificado_routes", prefixo: "/api/certificados" },
  { caminho: "./src/routes/mailing/mailing_route", prefixo: "/api/mailing" },
  { caminho: "./src/routes/notificacoes/notificacoes_route", prefixo: "/api/notificacoes" },
];

// Carregar associa√ß√µes da base de dados antes de inicializar rotas
require("./src/database/associations");

// Carregar todas as rotas e gerar relat√≥rio de sucessos
const rotasCarregadas = rotas.filter(({ caminho, prefixo }) => carregarRota(caminho, prefixo));
console.log(`üìä [ROTAS] Estat√≠sticas: ${rotasCarregadas.length}/${rotas.length} rotas carregadas com sucesso`);

// Servir ficheiros est√°ticos (uploads)
app.use("/uploads", express.static(path.join(process.cwd(), process.env.CAMINHO_PASTA_UPLOADS)));
app.use("/api/uploads", express.static(path.join(process.cwd(), process.env.CAMINHO_PASTA_UPLOADS)));

console.log(`üìÅ [FICHEIROS] Servindo uploads de: ${path.join(process.cwd(), process.env.CAMINHO_PASTA_UPLOADS)}`);

/**
 * Rota principal da API com informa√ß√µes de estado
 * Fornece diagn√≥stico sobre a sa√∫de do sistema
 */
app.get("/api", (req, res) => {
  const uptimeSeconds = process.uptime();
  const uptimeFormatted = `${Math.floor(uptimeSeconds / 3600)}h ${Math.floor((uptimeSeconds % 3600) / 60)}m ${Math.floor(uptimeSeconds % 60)}s`;
  
  res.json({
    message: "üöÄ API da Plataforma de Forma√ß√£o est√° a funcionar!",
    version: "1.0.0",
    status: "operational",
    timestamp: new Date().toISOString(),
    uptime: uptimeFormatted,
    rotas_carregadas: rotasCarregadas.length,
    total_rotas: rotas.length,
    taxa_sucesso_rotas: `${((rotasCarregadas.length / rotas.length) * 100).toFixed(1)}%`,
    websocket_ativo: true,
    websocket_ligacoes: io.engine.clientsCount,
    upload_dir: process.env.CAMINHO_PASTA_UPLOADS,
    node_env: process.env.NODE_ENV || 'development'
  });
});

/**
 * Rota de diagn√≥stico das vari√°veis de ambiente
 * √ötil para verificar configura√ß√£o em diferentes ambientes
 */
app.get("/api/debug/env", (req, res) => {
  res.json({
    NODE_ENV: process.env.NODE_ENV || 'development',
    PORT: process.env.PORT || 'n√£o definida',
    JWT_SECRET_EXISTS: !!process.env.JWT_SECRET,
    DB_CONFIG_EXISTS: !!(process.env.DB_HOST || process.env.DATABASE_URL),
    EMAIL_CONFIG_EXISTS: !!(process.env.EMAIL_USER && process.env.EMAIL_PASS),
    CAMINHO_PASTA_UPLOADS: process.env.CAMINHO_PASTA_UPLOADS,
    FRONTEND_URL: process.env.FRONTEND_URL || 'n√£o definida',
    WEBSOCKET_READY: true,
    WEBSOCKET_CORS_CONFIGURED: true,
    timestamp: new Date().toISOString()
  });
});

/**
 * Teste do sistema WebSocket
 * Verifica se o sistema de notifica√ß√µes est√° operacional
 */
app.get("/api/test/websocket", (req, res) => {
  const connectionsCount = io.engine.clientsCount;
  const rooms = Array.from(io.sockets.adapter.rooms.keys());
  const userRooms = rooms.filter(room => room.startsWith('user_'));
  const topicRooms = rooms.filter(room => room.startsWith('topico_'));
  const themeRooms = rooms.filter(room => room.startsWith('tema_'));
  
  res.json({
    message: "üîå Sistema WebSocket est√° operacional",
    status: "active",
    conexoes_ativas: connectionsCount,
    estatisticas_salas: {
      total: rooms.length,
      utilizadores: userRooms.length,
      topicos: topicRooms.length,
      temas: themeRooms.length
    },
    timestamp: new Date().toISOString(),
    test_endpoint: "/api/test/websocket/send"
  });
});

/**
 * Endpoint para testar envio de notifica√ß√µes WebSocket
 * Permite aos administradores testarem o sistema
 */
app.post("/api/test/websocket/send", (req, res) => {
  const { userId, message } = req.body;
  
  if (!userId) {
    return res.status(400).json({ error: "userId √© obrigat√≥rio" });
  }
  
  const testMessage = message || "Esta √© uma notifica√ß√£o de teste do sistema!";
  
  // Enviar notifica√ß√£o de teste
  io.to(`user_${userId}`).emit('nova_notificacao', {
    titulo: "üß™ Teste de Notifica√ß√£o",
    mensagem: testMessage,
    tipo: "teste",
    data: new Date(),
    isTest: true
  });
  
  res.json({
    message: `Notifica√ß√£o de teste enviada para utilizador ${userId}`,
    timestamp: new Date().toISOString()
  });
});

// Inicializa√ß√£o de agendamentos autom√°ticos (se dispon√≠vel)
try {
  const schedPath = path.join(__dirname, "src/utils/schedulers.js");
  if (fs.existsSync(schedPath)) {
    const { iniciarAgendamentos } = require(schedPath);
    iniciarAgendamentos();
    console.log("‚è∞ [SCHEDULER] Agendamentos autom√°ticos iniciados com sucesso");
  } else {
    console.log("‚ÑπÔ∏è [SCHEDULER] Ficheiro de agendamentos n√£o encontrado - funcionalidade opcional");
  }
} catch (error) {
  console.warn(`‚ö†Ô∏è [SCHEDULER] Falha ao iniciar agendamentos: ${error.message}`);
}

/**
 * Servir aplica√ß√£o React compilada (produ√ß√£o)
 * Suporte para Single Page Application com client-side routing
 */
const clienteBuildPath = path.join(__dirname, "../front/build");

if (fs.existsSync(clienteBuildPath)) {
  console.log(`‚öõÔ∏è [FRONTEND] Frontend React dispon√≠vel em: ${clienteBuildPath}`);
  app.use(express.static(clienteBuildPath));

  // Rota catch-all para SPA routing
  app.get("*", (req, res) => {
    // Excluir rotas da API do SPA routing
    if (req.path.startsWith("/api") || req.path.startsWith("/uploads")) {
      return res.status(404).json({ 
        message: "Endpoint n√£o encontrado",
        path: req.path,
        method: req.method
      });
    }
    
    res.sendFile(path.join(clienteBuildPath, "index.html"));
  });
} else {
  console.warn(`‚ö†Ô∏è [FRONTEND] Build do React n√£o encontrada em: ${clienteBuildPath}`);
  console.log(`‚ÑπÔ∏è [FRONTEND] A correr apenas API. Para servir frontend, executa: npm run build`);
  
  // Rota de fallback quando n√£o h√° frontend
  app.get("*", (req, res) => {
    if (req.path.startsWith("/api") || req.path.startsWith("/uploads")) {
      return res.status(404).json({ message: "Endpoint n√£o encontrado" });
    }
    
    res.json({
      message: "üöÄ API da Plataforma de Forma√ß√£o",
      info: "Frontend n√£o dispon√≠vel. Acede √† documenta√ß√£o da API em /api",
      endpoints: [
        "/api - Informa√ß√µes da API",
        "/api/debug/env - Diagn√≥stico do ambiente",
        "/api/test/websocket - Teste do WebSocket"
      ]
    });
  });
}

/**
 * Middleware global de tratamento de erros
 * Captura erros n√£o tratados e fornece respostas consistentes
 */
app.use((err, req, res, next) => {
  console.error("üí• [ERROR] Erro interno do servidor:", err.message);
  console.error("üìç [ERROR] Stack trace:", err.stack);
  console.error("üåê [ERROR] URL:", req.url);
  console.error("üìù [ERROR] M√©todo:", req.method);
  
  res.status(500).json({ 
    message: "Erro interno do servidor",
    timestamp: new Date().toISOString(),
    requestId: req.headers['x-request-id'] || 'unknown',
    error: process.env.NODE_ENV === 'development' ? err.message : undefined
  });
});

/**
 * Handler para rotas n√£o encontradas (404)
 */
app.use((req, res) => {
  console.warn(`‚ö†Ô∏è [404] Rota n√£o encontrada: ${req.method} ${req.url}`);
  
  res.status(404).json({
    message: "Rota n√£o encontrada",
    path: req.url,
    method: req.method,
    timestamp: new Date().toISOString(),
    suggestion: "Verifica a documenta√ß√£o da API em /api"
  });
});

// Inicializa√ß√£o do servidor
const PORT = process.env.PORT || 4000;
const HOST = process.env.HOST || '0.0.0.0';

server.listen(PORT, HOST, () => {
  console.log(`
üöÄ===========================================
   üéØ Servidor iniciado com sucesso!
   üî¢ Porta: ${PORT}
   üè† Host: ${HOST}
   üåê API: http://${HOST === '0.0.0.0' ? 'localhost' : HOST}:${PORT}/api
   üîå WebSocket: ATIVO (Socket.IO)
   üîî Notifica√ß√µes: TEMPO REAL
   üìÅ Uploads: ${process.env.CAMINHO_PASTA_UPLOADS}
   üìä Rotas: ${rotasCarregadas.length}/${rotas.length} (${((rotasCarregadas.length / rotas.length) * 100).toFixed(1)}%)
   üåç Ambiente: ${process.env.NODE_ENV || 'development'}
üöÄ===========================================
  `);

  // Mostrar IPs dispon√≠veis para liga√ß√£o
  const os = require('os');
  const networkInterfaces = os.networkInterfaces();
  
  console.log('\nüåê IPs dispon√≠veis para liga√ß√£o:');
  console.log(`üè† Local: http://localhost:${PORT}`);
  
  Object.keys(networkInterfaces).forEach((interfaceName) => {
    const addresses = networkInterfaces[interfaceName];
    addresses.forEach((address) => {
      if (address.family === 'IPv4' && !address.internal) {
        console.log(`üåç Rede (${interfaceName}): http://${address.address}:${PORT}`);
      }
    });
  });
  
  // Informa√ß√µes de desenvolvimento
  if (process.env.NODE_ENV === 'development') {
    console.log('\nüõ†Ô∏è Informa√ß√µes de desenvolvimento:');
    console.log(`üì° WebSocket: ws://localhost:${PORT}/socket.io`);
    console.log(`üß™ Teste WebSocket: http://localhost:${PORT}/api/test/websocket`);
    console.log(`üîß Debug ambiente: http://localhost:${PORT}/api/debug/env`);
  }
  
  console.log('\nüöÄ===========================================\n');
});

/**
 * Gest√£o graceful de shutdown
 * Garante encerramento limpo de liga√ß√µes WebSocket
 */
process.on('SIGTERM', () => {
  console.log('üõë [SHUTDOWN] SIGTERM recebido, a iniciar shutdown graceful...');
  
  server.close(() => {
    console.log('‚úÖ [SHUTDOWN] Servidor HTTP fechado.');
    
    io.close(() => {
      console.log('‚úÖ [SHUTDOWN] WebSocket fechado.');
      process.exit(0);
    });
  });
});

process.on('SIGINT', () => {
  console.log('\nüõë [SHUTDOWN] SIGINT recebido (Ctrl+C), a encerrar servidor...');
  
  server.close(() => {
    console.log('‚úÖ [SHUTDOWN] Servidor encerrado com sucesso.');
    process.exit(0);
  });
});

// Capturar erros n√£o tratados para evitar crashes
process.on('uncaughtException', (error) => {
  console.error('üí• [FATAL] Erro n√£o capturado:', error);
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('üí• [FATAL] Promise rejeitada n√£o tratada:', reason);
  console.error('üîç [FATAL] Promise:', promise);
  process.exit(1);
});