const bcrypt = require("bcrypt");
const jwt = require("jsonwebtoken");
const User = require("../../database/models/User.js");
const User_Pendente = require("../../database/models/User_Pendente.js");
const Cargo = require("../../database/models/Cargo");
const { sendRegistrationEmail } = require("../../utils/emailService");
const fs = require("fs");
const path = require("path");
const uploadUtils = require("../../middleware/upload");


const FormadorAssociacoesPendentes = require("../../database/models/Formador_Associacoes_Pendentes");
const FormadorCategoria = require("../../database/models/Formador_Categoria");
const FormadorArea = require("../../database/models/Formador_Area");
const Inscricao_Curso = require("../../database/models/Inscricao_Curso");

/**
 * FUN√á√ïES AUXILIARES
 */

/**
 * Fun√ß√£o para verificar email e enviar confirma√ß√£o
 * @param {Object} userData - Dados do usu√°rio para criar
 * @returns {Object} - Objeto com status do envio e dados do usu√°rio criado ou erro
 */
const verifyAndSendEmail = async (userData) => {
  try {
    // Verificar se o email j√° existe em usu√°rios ativos
    const existingUser = await User.findOne({ where: { email: userData.email } });
    if (existingUser) {
      return {
        success: false,
        error: "Este email j√° est√° registrado. Por favor, use outro email ou recupere sua senha."
      };
    }

    // Verificar se h√° um registro pendente com este email
    const pendingUser = await User_Pendente.findOne({ where: { email: userData.email } });
    if (pendingUser) {
      // Se o registro estiver expirado, podemos remov√™-lo e permitir um novo
      if (new Date() > new Date(pendingUser.expires_at)) {
        await pendingUser.destroy();
      } else {
        return {
          success: false,
          error: "J√° existe um registro pendente com este email. Verifique sua caixa de entrada para ativar sua conta ou aguarde o prazo de expira√ß√£o para tentar novamente."
        };
      }
    }

    // Testar o envio de email antes de criar o usu√°rio
    const tempUser = {
      id: 0, // ID tempor√°rio
      nome: userData.nome,
      email: userData.email,
      telefone: userData.telefone
    };

    try {
      console.log(`Verificando se √© poss√≠vel enviar email para: ${userData.email}`);
      // Nota: N√£o envie o email real aqui, apenas verifique se o endere√ßo √© v√°lido
      // Podemos usar uma valida√ß√£o mais simples aqui
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(userData.email)) {
        throw new Error("Endere√ßo de email inv√°lido");
      }

      console.log('Valida√ß√£o de email passou!');
      return { success: true };
    } catch (emailError) {
      console.error("Erro ao verificar email:", emailError);
      return {
        success: false,
        error: "N√£o foi poss√≠vel validar o endere√ßo de email. Verifique se o endere√ßo est√° correto."
      };
    }
  } catch (error) {
    console.error("Erro ao verificar email:", error);
    return {
      success: false,
      error: "Erro ao verificar disponibilidade do email."
    };
  }
};

const prepararPastaUsuario = async (userId) => {
  try {
    // Buscar informa√ß√µes do usu√°rio
    const user = await User.findByPk(userId);

    if (!user || !user.email) {
      throw new Error("Usu√°rio n√£o encontrado ou sem email");
    }

    // Criar slug do usu√°rio baseado no email
    const userSlug = user.email.replace(/@/g, '_at_').replace(/\./g, '_');
    const userDir = path.join(uploadUtils.BASE_UPLOAD_DIR, 'users', userSlug);

    // Garantir que o diret√≥rio exista
    uploadUtils.ensureDir(userDir);

    // Retornar informa√ß√µes √∫teis
    return {
      user,
      userSlug,
      userDir,
      dbPathBase: `uploads/users/${userSlug}`
    };
  } catch (error) {
    console.error("Erro ao preparar pasta do usu√°rio:", error);
    throw error;
  }
};

const initDefaultUserImages = () => {
  try {
    // Garantir que o diret√≥rio base exista
    const usersDir = path.join(uploadUtils.BASE_UPLOAD_DIR, 'users');
    uploadUtils.ensureDir(usersDir);

    // Caminhos para os arquivos padr√£o
    const avatarPath = path.join(usersDir, 'AVATAR.png');
    const capaPath = path.join(usersDir, 'CAPA.png');

    // Verificar se os arquivos padr√£o j√° existem
    if (!fs.existsSync(avatarPath) || !fs.existsSync(capaPath)) {
      console.log('Criando arquivos de imagem padr√£o para usu√°rios...');

      // Se os arquivos n√£o existirem, pode usar um m√©todo para cri√°-los
      // Isso pode envolver copiar de uma pasta de recursos ou criar imagens padr√£o

      // Exemplo: Se as imagens estiverem em uma pasta 'resources'
      const resourcesDir = path.join(__dirname, '../../resources');

      if (fs.existsSync(path.join(resourcesDir, 'AVATAR.png')) &&
        fs.existsSync(path.join(resourcesDir, 'CAPA.png'))) {

        fs.copyFileSync(
          path.join(resourcesDir, 'AVATAR.png'),
          avatarPath
        );

        fs.copyFileSync(
          path.join(resourcesDir, 'CAPA.png'),
          capaPath
        );

        console.log('Imagens padr√£o copiadas com sucesso.');
      } else {
        console.warn('Arquivos de imagem padr√£o n√£o encontrados em resources!');
        // Aqui voc√™ poderia criar imagens em branco ou usar outra estrat√©gia
      }
    }
  } catch (error) {
    console.error('Erro ao inicializar imagens padr√£o:', error);
  }
};

/**
 * FUN√á√ïES DE REGISTRO E AUTENTICA√á√ÉO
 */

/**
 * Fun√ß√£o para gerar uma senha aleat√≥ria segura
 * @param {number} length - Comprimento da senha
 * @returns {string} - Senha aleat√≥ria gerada
 */
const generateRandomPassword = (length = 10) => {
  const charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_-+=";
  let password = "";

  // Garantir que pelo menos um caractere de cada categoria esteja presente
  password += charset.substr(Math.floor(Math.random() * 26), 1); // Letra mai√∫scula
  password += charset.substr(26 + Math.floor(Math.random() * 26), 1); // Letra min√∫scula
  password += charset.substr(52 + Math.floor(Math.random() * 10), 1); // N√∫mero
  password += charset.substr(62 + Math.floor(Math.random() * 14), 1); // Caractere especial

  // Preencher o resto da senha aleatoriamente
  for (let i = 4; i < length; i++) {
    password += charset.charAt(Math.floor(Math.random() * charset.length));
  }

  // Embaralhar a senha para garantir que n√£o haja um padr√£o reconhec√≠vel
  return password
    .split('')
    .sort(() => 0.5 - Math.random())
    .join('');
};

/**
 * Criar um novo usu√°rio
 * @param {object} req - Objeto de requisi√ß√£o
 * @param {object} res - Objeto de resposta
 */
const createUser = async (req, res) => {
  try {
    console.log("üîç Iniciando cria√ß√£o de usu√°rio");
    const { nome, email, password, idade, telefone, morada, codigo_postal, cargo } = req.body;
    const senha_temporaria = password; // Guardar a senha em texto puro para o email

    // Validar campos obrigat√≥rios
    if (!nome || !email || !password) {
      return res.status(400).json({ message: "Campos obrigat√≥rios: nome, email e password" });
    }

    // Verificar se o e-mail j√° est√° em uso
    const emailExistente = await User.findOne({ where: { email } });
    if (emailExistente) {
      return res.status(400).json({ message: "Este e-mail j√° est√° em uso" });
    }

    // Determinar o cargo padr√£o (3 = formando)
    const cargoId = cargo === 'formador' ? 2 : 3;
    const cargoDescricao = cargo === 'formador' ? 'Formador' : 'Formando';

    // Hash da senha
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(password, salt);

    // Caminho da imagem (se existir)
    let imagemPath = null;
    if (req.file) {
      // Usar email como parte do nome do arquivo para evitar conflitos
      const userSlug = email.replace(/@/g, '_at_').replace(/\./g, '_');
      imagemPath = `uploads/users/${userSlug}/${email}_AVATAR.png`;

      // Criar diret√≥rio do usu√°rio se ainda n√£o existir
      const userDir = path.join(uploadUtils.BASE_UPLOAD_DIR, 'users', userSlug);
      uploadUtils.ensureDir(userDir);

      console.log(`‚úÖ Imagem salva em: ${imagemPath}`);
    }

    // Criar o usu√°rio no banco de dados
    const novoUsuario = await User.create({
      nome,
      email,
      password: hashedPassword,
      idade: idade || null,
      telefone: telefone || null,
      morada: morada || null,
      codigo_postal: codigo_postal || null,
      id_cargo: cargoId,
      foto_perfil: imagemPath,
      ativo: true,
      data_registo: new Date()
    });

    // Remover a senha da resposta
    const usuarioSemSenha = { ...novoUsuario.toJSON() };
    delete usuarioSemSenha.password;

    // Enviar email com os dados da conta
    try {
      // Gerar token para anexar ao email (opcional, podemos usar s√≥ para fins informativos)
      const token = jwt.sign(
        { id_utilizador: novoUsuario.id_utilizador, email },
        process.env.JWT_SECRET,
        { expiresIn: "24h" }
      );

      // Preparar dados para o email
      const userForEmail = {
        id: novoUsuario.id_utilizador,
        nome: novoUsuario.nome,
        email: novoUsuario.email,
        idade: novoUsuario.idade,
        telefone: novoUsuario.telefone,
        morada: novoUsuario.morada,
        codigo_postal: novoUsuario.codigo_postal,
        cargo_descricao: cargoDescricao,
        senha_temporaria: senha_temporaria, // Enviar a senha em texto puro no email
        token: token
      };

      // Enviar email com os dados da conta
      await sendRegistrationEmail(userForEmail);
      console.log(`‚úÖ Email enviado para: ${email}`);
    } catch (emailError) {
      console.error("‚ö†Ô∏è Erro ao enviar email:", emailError);
      // Continuar normalmente mesmo que o email falhe
    }

    console.log(`‚úÖ Usu√°rio criado com sucesso: ${novoUsuario.id_utilizador}`);

    return res.status(201).json({
      message: `Usu√°rio ${cargo === 'formador' ? 'formador' : ''} criado com sucesso!`,
      ...usuarioSemSenha
    });

  } catch (error) {
    console.error("‚ùå Erro ao criar usu√°rio:", error);
    return res.status(500).json({
      message: "Erro ao criar usu√°rio",
      error: error.message,
      detalhes: error.stack
    });
  }
};





const confirmAccount = async (req, res) => {
  try {
    const { token } = req.body;

    if (!token) {
      return res.status(400).json({ message: "Token n√£o fornecido" });
    }

    // Verificar se o token √© v√°lido e n√£o expirou
    let decoded;
    try {
      decoded = jwt.verify(token, process.env.JWT_SECRET);
    } catch (error) {
      return res.status(401).json({ message: "Token inv√°lido ou expirado" });
    }

    // Buscar o registro pendente
    const pendingUser = await User_Pendente.findOne({
      where: {
        email: decoded.email,
        token: token
      }
    });

    if (!pendingUser) {
      return res.status(404).json({ message: "Registro pendente n√£o encontrado" });
    }

    // Verificar se o token n√£o expirou (dupla verifica√ß√£o)
    if (new Date() > new Date(pendingUser.expires_at)) {
      await pendingUser.destroy();
      return res.status(401).json({ message: "Link de confirma√ß√£o expirado. Por favor, registre-se novamente." });
    }

    // Criar o usu√°rio definitivo
    const newUser = await User.create({
      id_cargo: pendingUser.id_cargo,
      nome: pendingUser.nome,
      idade: pendingUser.idade,
      email: pendingUser.email,
      telefone: pendingUser.telefone,
      password: pendingUser.password, // J√° est√° hasheada
      primeiro_login: 1,
      foto_perfil: "AVATAR.png",
      foto_capa: "CAPA.png"
    });

    // NOVO: Buscar e processar associa√ß√µes pendentes
    try {
      const associacoesPendentes = await FormadorAssociacoesPendentes.findOne({
        where: { id_pendente: pendingUser.id }
      });

      if (associacoesPendentes) {
        console.log("‚úÖ Encontradas associa√ß√µes pendentes para processar");
        
        // Processar categorias
        if (associacoesPendentes.categorias && associacoesPendentes.categorias.length > 0) {
          console.log(`‚úÖ Processando ${associacoesPendentes.categorias.length} categorias`);
          const dataAtual = new Date();
          
          for (const categoria of associacoesPendentes.categorias) {
            await FormadorCategoria.create({
              id_formador: newUser.id_utilizador,
              id_categoria: typeof categoria === 'object' ? categoria.id_categoria : categoria,
              data_associacao: dataAtual
            });
          }
        }
        
        // Processar √°reas
        if (associacoesPendentes.areas && associacoesPendentes.areas.length > 0) {
          console.log(`‚úÖ Processando ${associacoesPendentes.areas.length} √°reas`);
          const dataAtual = new Date();
          
          for (const area of associacoesPendentes.areas) {
            await FormadorArea.create({
              id_formador: newUser.id_utilizador,
              id_area: typeof area === 'object' ? area.id_area : area,
              data_associacao: dataAtual
            });
          }
        }
        
        // Processar cursos
        if (associacoesPendentes.cursos && associacoesPendentes.cursos.length > 0) {
          console.log(`‚úÖ Processando ${associacoesPendentes.cursos.length} cursos`);
          
          for (const cursoId of associacoesPendentes.cursos) {
            try {
              // Criar inscri√ß√£o no curso
              await Inscricao_Curso.create({
                id_utilizador: newUser.id_utilizador,
                id_curso: typeof cursoId === 'object' ? cursoId.id_curso : cursoId,
                data_inscricao: new Date(),
                estado: "inscrito"
              });
              
              console.log(`‚úÖ Formador inscrito no curso ID: ${cursoId}`);
            } catch (error) {
              console.error(`‚ö†Ô∏è Erro ao inscrever formador no curso ID: ${cursoId}`, error);
              // Continuar com os pr√≥ximos cursos mesmo se um falhar
            }
          }
        }


        // Remover as associa√ß√µes pendentes
        await associacoesPendentes.destroy();
        console.log("‚úÖ Associa√ß√µes pendentes processadas e removidas");
      }
    } catch (assocError) {
      console.error("‚ö†Ô∏è Erro ao processar associa√ß√µes pendentes:", assocError);
      // N√£o falharemos a confirma√ß√£o por causa disso
    }

    // Criar pasta do usu√°rio ap√≥s confirmar a conta
    try {
      // Criar diret√≥rio do usu√°rio baseado no email
      const userSlug = pendingUser.email.replace(/@/g, '_at_').replace(/\./g, '_');
      const userDir = path.join(uploadUtils.BASE_UPLOAD_DIR, 'users', userSlug);

      // Garantir que o diret√≥rio exista
      uploadUtils.ensureDir(userDir);

      console.log(`Diret√≥rio do usu√°rio criado em: ${userDir}`);

      // Copiar imagens padr√£o para a pasta do usu√°rio, se necess√°rio
      const avatarSource = path.join(uploadUtils.BASE_UPLOAD_DIR, 'users', 'AVATAR.png');
      const capaSource = path.join(uploadUtils.BASE_UPLOAD_DIR, 'users', 'CAPA.png');

      const avatarDest = path.join(userDir, `${pendingUser.email}_AVATAR.png`);
      const capaDest = path.join(userDir, `${pendingUser.email}_CAPA.png`);

      // Verificar se as imagens padr√£o existem e copi√°-las
      if (fs.existsSync(avatarSource)) {
        fs.copyFileSync(avatarSource, avatarDest);
        console.log(`Avatar padr√£o copiado para ${avatarDest}`);
      }

      if (fs.existsSync(capaSource)) {
        fs.copyFileSync(capaSource, capaDest);
        console.log(`Capa padr√£o copiada para ${capaDest}`);
      }

      // Atualizar os caminhos das imagens no banco de dados
      const dbPathAvatar = `uploads/users/${userSlug}/${pendingUser.email}_AVATAR.png`;
      const dbPathCapa = `uploads/users/${userSlug}/${pendingUser.email}_CAPA.png`;

      await User.update(
        {
          foto_perfil: dbPathAvatar,
          foto_capa: dbPathCapa
        },
        { where: { id_utilizador: newUser.id_utilizador } }
      );

      console.log('Caminhos das imagens atualizados no banco de dados');
    } catch (dirError) {
      console.error("Erro ao criar diret√≥rio do usu√°rio:", dirError);
      // N√£o interromper o processo se a cria√ß√£o da pasta falhar
    }

    // Remover o registro pendente
    await pendingUser.destroy();

    // Gerar um token de autentica√ß√£o para login autom√°tico
    const authToken = jwt.sign(
      {
        id_utilizador: newUser.id_utilizador,
        nome: newUser.nome,
        id_cargo: newUser.id_cargo
      },
      process.env.JWT_SECRET,
      { expiresIn: "1h" }
    );

    res.status(200).json({
      message: "Conta confirmada com sucesso!",
      token: authToken,
      user: {
        id_utilizador: newUser.id_utilizador,
        nome: newUser.nome,
        email: newUser.email
      }
    });
  } catch (error) {
    console.error("Erro ao confirmar conta:", error);
    res.status(500).json({ message: "Erro no servidor ao confirmar conta" });
  }
};

const loginUser = async (req, res) => {
  try {
    const { email, password } = req.body;

    const user = await User.findOne({
      where: { email },
      include: [{ model: Cargo, as: "cargo" }]
    });

    if (!user) return res.status(404).json({ message: "Utilizador n√£o encontrado!" });

    const validPassword = await bcrypt.compare(password, user.password);
    if (!validPassword) return res.status(401).json({ message: "Credenciais inv√°lidas!" });

    // MODIFICA√á√ÉO: Incluir o email do usu√°rio no token
    const token = jwt.sign(
      {
        id_utilizador: user.id_utilizador,
        nome: user.nome,
        email: user.email, // ADICIONADO: incluir email no token
        id_cargo: user.cargo?.id_cargo,
        cargo: user.cargo?.descricao || null
      },
      process.env.JWT_SECRET || 'segredo', // Usa o segredo padr√£o se n√£o estiver definido
      { expiresIn: "1h" }
    );

    res.json({
      token,
      id_utilizador: user.id_utilizador,
      nome: user.nome,
      email: user.email, // ADICIONADO: incluir email na resposta
      id_cargo: user.cargo?.id_cargo,
      cargo: user.cargo?.descricao || null,
      primeiro_login: user.primeiro_login
    });
  } catch (error) {
    console.error("Erro ao fazer login:", error);
    res.status(500).json({ message: "Erro no servidor ao fazer login." });
  }
};

const verifyToken = (req, res) => {
  const token = req.body.token || req.headers.authorization?.split(' ')[1];

  if (!token) {
    return res.status(401).json({ message: "Token n√£o fornecido" });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    res.json({ valid: true, user: decoded });
  } catch (error) {
    res.status(401).json({ valid: false, message: "Token inv√°lido ou expirado" });
  }
};

const resendConfirmation = async (req, res) => {
  try {
    const { email } = req.body;

    if (!email) {
      return res.status(400).json({ message: "Email n√£o fornecido" });
    }

    // Buscar registro pendente
    const pendingUser = await User_Pendente.findOne({ where: { email } });

    if (!pendingUser) {
      return res.status(404).json({ message: "Registro pendente n√£o encontrado para este email" });
    }

    // Verificar se o usu√°rio j√° est√° registrado
    const existingUser = await User.findOne({ where: { email } });
    if (existingUser) {
      await pendingUser.destroy(); // Remover registro pendente obsoleto
      return res.status(400).json({
        message: "Este email j√° est√° registrado como usu√°rio ativo. Por favor, fa√ßa login ou recupere sua senha."
      });
    }

    // Gerar novo token
    const token = jwt.sign(
      { email: pendingUser.email, nome: pendingUser.nome },
      process.env.JWT_SECRET,
      { expiresIn: "24h" }
    );

    // Atualizar token e data de expira√ß√£o
    const expires_at = new Date();
    expires_at.setHours(expires_at.getHours() + 24);

    await pendingUser.update({
      token,
      expires_at
    });

    // Enviar novo email
    try {
      const userForEmail = {
        id_utilizador: pendingUser.id,
        nome: pendingUser.nome,
        email: pendingUser.email,
        token: token
      };

      await sendRegistrationEmail(userForEmail);
      console.log('Email de confirma√ß√£o reenviado com sucesso!');

      res.json({ message: "Email de confirma√ß√£o reenviado com sucesso!" });
    } catch (emailError) {
      console.error("Erro ao reenviar email:", emailError);
      res.status(500).json({ message: "Erro ao enviar o email de confirma√ß√£o." });
    }
  } catch (error) {
    console.error("Erro ao reenviar confirma√ß√£o:", error);
    res.status(500).json({ message: "Erro no servidor ao processar a solicita√ß√£o." });
  }
};

/**
 * FUN√á√ïES DE GEST√ÉO DE PERFIL
 */

const perfilUser = async (req, res) => {
  try {
    console.log('Usu√°rio autenticado:', req.user);

    const userId = req.user.id_utilizador;
    console.log('ID do usu√°rio:', userId);

    const user = await User.findByPk(userId, {
      include: [{ model: Cargo, as: 'cargo' }]
    });

    console.log('Usu√°rio encontrado:', user ? 'Sim' : 'N√£o');

    if (!user) {
      console.log('Usu√°rio n√£o encontrado');
      return res.status(404).json({ message: "Utilizador n√£o encontrado" });
    }

    // Adicionar imagem default se n√£o existir
    if (!user.foto_perfil) {
      console.log('Definindo foto de perfil padr√£o');
      user.foto_perfil = "AVATAR.png";
    }
    if (!user.foto_capa) {
      console.log('Definindo foto de capa padr√£o');
      user.foto_capa = "CAPA.png";
    }

    // Convertemos primeiro_login para n√∫mero para garantir 
    // que o frontend receba o valor correto
    const userResponse = {
      ...user.get({ plain: true }),
      primeiro_login: Number(user.primeiro_login)
    };

    console.log('Perfil recuperado com sucesso, primeiro_login:', userResponse.primeiro_login);
    res.json(userResponse);
  } catch (error) {
    console.error("Erro ao obter o perfil:", error);
    res.status(500).json({ message: "Erro ao obter o perfil do utilizador" });
  }
};

const updatePerfilUser = async (req, res) => {
  try {
    const userId = req.user.id_utilizador;
    const { nome, email, telefone, idade } = req.body;

    const user = await User.findByPk(userId);
    if (!user) {
      return res.status(404).json({ message: "Utilizador n√£o encontrado" });
    }

    await User.update(
      { nome, email, telefone, idade },
      { where: { id_utilizador: userId } }
    );

    const updatedUser = await User.findByPk(userId);
    res.json(updatedUser);
  } catch (error) {
    console.error("Erro ao atualizar perfil:", error);
    res.status(500).json({ message: "Erro ao atualizar o perfil do utilizador" });
  }
};

const changePassword = async (req, res) => {
  try {
    console.log('Requisi√ß√£o de altera√ß√£o de senha recebida:', req.body);

    // Extrair dados da requisi√ß√£o
    const { token, password, id_utilizador, senha_atual, nova_senha } = req.body;

    // Caso 1: Altera√ß√£o via token (recupera√ß√£o de senha)
    if (token) {
      console.log('Altera√ß√£o via token de recupera√ß√£o de senha');

      let decoded;
      try {
        decoded = jwt.verify(token, process.env.JWT_SECRET);
      } catch (error) {
        console.error('Token inv√°lido:', error);
        return res.status(401).json({ message: "Token inv√°lido ou expirado" });
      }

      const userId = decoded.id_utilizador;
      const salt = await bcrypt.genSalt(10);
      const hashedPassword = await bcrypt.hash(password, salt);

      await User.update(
        {
          password: hashedPassword,
          primeiro_login: 0
        },
        { where: { id_utilizador: userId } }
      );

      console.log('Senha alterada com sucesso via token de recupera√ß√£o');
      return res.json({
        message: "Senha alterada com sucesso",
        primeiro_login: 0
      });
    }

    // Caso 2: Altera√ß√£o via autentica√ß√£o normal
    // Se o utilizador estiver autenticado, usar o ID do token
    let userIdToUse = id_utilizador;

    // Se n√£o foi fornecido ID explicitamente mas est√° autenticado
    if (!userIdToUse && req.user && req.user.id_utilizador) {
      console.log('Usando ID do usu√°rio do token:', req.user.id_utilizador);
      userIdToUse = req.user.id_utilizador;
    }

    if (!userIdToUse) {
      console.error('ID do usu√°rio n√£o fornecido');
      return res.status(400).json({ message: "ID do usu√°rio √© obrigat√≥rio" });
    }

    console.log('Buscando usu√°rio com ID:', userIdToUse);
    const user = await User.findByPk(userIdToUse);

    if (!user) {
      console.error('Usu√°rio n√£o encontrado');
      return res.status(404).json({ message: "Usu√°rio n√£o encontrado" });
    }

    // Verificar senha atual a menos que seja primeiro login
    if (user.primeiro_login !== 1 && senha_atual) {
      console.log('Verificando senha atual (n√£o √© primeiro login)');
      const validPassword = await bcrypt.compare(senha_atual, user.password);
      if (!validPassword) {
        console.error('Senha atual incorreta');
        return res.status(401).json({ message: "Senha atual incorreta" });
      }
    } else {
      console.log('Primeiro login ou senha atual n√£o fornecida');
    }

    // Determinar qual senha usar
    const senhaParaAtualizar = nova_senha || password;

    if (!senhaParaAtualizar) {
      console.error('Nova senha n√£o fornecida');
      return res.status(400).json({ message: "Nova senha √© obrigat√≥ria" });
    }

    console.log('Gerando hash da nova senha');
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(senhaParaAtualizar, salt);

    console.log('Atualizando senha e definindo primeiro_login como 0');
    const updateResult = await User.update(
      {
        password: hashedPassword,
        primeiro_login: 0
      },
      { where: { id_utilizador: userIdToUse } }
    );

    console.log('Resultado da atualiza√ß√£o:', updateResult);

    return res.json({
      message: "Senha alterada com sucesso",
      primeiro_login: 0
    });
  } catch (error) {
    console.error("Erro ao alterar senha:", error);
    res.status(500).json({ message: "Erro no servidor ao alterar senha" });
  }
};


















/**
 * FUN√á√ïES DE UPLOAD DE IMAGENS
 */



/**
 * Fun√ß√£o auxiliar para migrar e limpar arquivos de imagem do usu√°rio
 * Esta fun√ß√£o garante que apenas os arquivos mais recentes permane√ßam
 * @param {string} userDir - Diret√≥rio do usu√°rio
 * @param {string} userEmail - Email do usu√°rio
 * @param {string} tipo - Tipo de imagem (AVATAR ou CAPA)
 * @returns {Object} Informa√ß√µes sobre o arquivo mais recente
 */
const migrarELimparArquivosImagem = async (userDir, userEmail, tipo) => {
  console.log(`üßπ LIMPEZA: Iniciando migra√ß√£o/limpeza de arquivos ${tipo} para ${userEmail}`);
  
  try {
    // Garantir que o diret√≥rio exista
    if (!fs.existsSync(userDir)) {
      console.log(`üßπ LIMPEZA: Diret√≥rio ${userDir} n√£o existe, criando...`);
      fs.mkdirSync(userDir, { recursive: true });
      return null;
    }
    
    // Ler todos os arquivos no diret√≥rio
    const files = fs.readdirSync(userDir);
    
    // Filtrar arquivos pelo tipo (AVATAR ou CAPA)
    const tipoFiles = files.filter(file => 
      file.includes(`${userEmail}_${tipo}`) || 
      file.startsWith(`${userEmail}_${tipo}_`)
    );
    
    console.log(`üßπ LIMPEZA: Encontrados ${tipoFiles.length} arquivos de ${tipo}`);
    
    if (tipoFiles.length === 0) {
      console.log(`üßπ LIMPEZA: Nenhum arquivo de ${tipo} encontrado`);
      return null;
    }
    
    // Obter informa√ß√µes dos arquivos
    const fileInfos = tipoFiles.map(file => {
      const filePath = path.join(userDir, file);
      const stats = fs.statSync(filePath);
      
      // Extrair timestamp do nome ou usar a data de modifica√ß√£o
      let timestamp;
      const tsMatch = file.match(/_${tipo}_(\d+)\.png$/);
      if (tsMatch) {
        timestamp = parseInt(tsMatch[1]);
      } else {
        timestamp = stats.mtimeMs;
      }
      
      return {
        file,
        path: filePath,
        size: stats.size,
        timestamp,
        modified: stats.mtime
      };
    });
    
    // Ordenar por timestamp (mais recente primeiro)
    fileInfos.sort((a, b) => b.timestamp - a.timestamp);
    
    const newestFile = fileInfos[0];
    
    // Se temos mais de um arquivo, manter apenas o mais recente
    if (fileInfos.length > 1) {
      console.log(`üßπ LIMPEZA: Migrando para novo formato e mantendo apenas o arquivo mais recente (${newestFile.file})`);
      
      // Se o arquivo mais recente n√£o estiver no formato com timestamp, migrar
      if (!newestFile.file.match(/_${tipo}_\d+\.png$/)) {
        const timestamp = Date.now();
        const newFilename = `${userEmail}_${tipo}_${timestamp}.png`;
        const newFilePath = path.join(userDir, newFilename);
        
        console.log(`üßπ LIMPEZA: Migrando arquivo ${newestFile.file} para novo formato: ${newFilename}`);
        fs.copyFileSync(newestFile.path, newFilePath);
        
        // Atualizar a refer√™ncia para o novo arquivo
        newestFile.file = newFilename;
        newestFile.path = newFilePath;
        newestFile.timestamp = timestamp;
      }
      
      // Remover os arquivos mais antigos
      for (let i = 1; i < fileInfos.length; i++) {
        console.log(`üßπ LIMPEZA: Removendo arquivo antigo: ${fileInfos[i].file}`);
        fs.unlinkSync(fileInfos[i].path);
      }
    }
    
    // Garantir que o arquivo tenha conte√∫do v√°lido
    if (newestFile.size === 0) {
      console.log(`üßπ LIMPEZA: Arquivo vazio detectado (${newestFile.file}), removendo...`);
      fs.unlinkSync(newestFile.path);
      return null;
    }
    
    console.log(`üßπ LIMPEZA: Arquivo final de ${tipo}: ${newestFile.file} (${formatBytes(newestFile.size)})`);
    
    // Retornar informa√ß√µes do arquivo mais recente
    return {
      filename: newestFile.file,
      path: newestFile.path,
      size: newestFile.size,
      timestamp: newestFile.timestamp,
      dbPath: `uploads/users/${userEmail.replace(/@/g, '_at_').replace(/\./g, '_')}/${newestFile.file}`
    };
    
  } catch (error) {
    console.error(`üî¥ LIMPEZA: Erro ao migrar/limpar arquivos ${tipo}:`, error);
    return null;
  }
};

// Fun√ß√£o auxiliar para formatar bytes
const formatBytes = (bytes, decimals = 2) => {
  if (bytes === 0) return '0 Bytes';
  
  const k = 1024;
  const dm = decimals < 0 ? 0 : decimals;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
  
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
};



const uploadImagemPerfil = async (req, res) => {
  try {
    // 1. Verificar se a imagem foi enviada
    if (!req.file) {
      return res.status(400).json({ success: false, message: "Nenhuma imagem enviada" });
    }

    // 2. Verificar se o usu√°rio existe
    const userId = req.user.id_utilizador;
    const userEmail = req.user.email;
    
    if (!userId || !userEmail) {
      return res.status(401).json({ success: false, message: "Usu√°rio n√£o autenticado corretamente" });
    }

    // 3. Buscar o usu√°rio para garantir que existe
    const user = await User.findByPk(userId);
    if (!user) {
      return res.status(404).json({ success: false, message: "Usu√°rio n√£o encontrado" });
    }

    // 4. Preparar o diret√≥rio e caminho do arquivo
    const userSlug = userEmail.replace(/@/g, '_at_').replace(/\./g, '_');
    const userDir = path.join(uploadUtils.BASE_UPLOAD_DIR, 'users', userSlug);
    
    // Garantir que o diret√≥rio exista
    uploadUtils.ensureDir(userDir);
    
    // Nome fixo do arquivo (sem timestamp)
    const fileName = `${userEmail}_AVATAR.png`;
    const filePath = path.join(userDir, fileName);
    
    // Caminho relativo para o banco de dados
    const dbPath = `uploads/users/${userSlug}/${fileName}`;

    // 5. Remover qualquer arquivo existente com mesmo nome base
    const files = fs.readdirSync(userDir);
    files.forEach(file => {
      // Encontrar TODOS os arquivos que correspondem ao padr√£o email_AVATAR*.png
      if (file.startsWith(`${userEmail}_AVATAR`) && file.endsWith('.png')) {
        const oldFilePath = path.join(userDir, file);
        try {
          fs.unlinkSync(oldFilePath);
          console.log(`Arquivo antigo removido: ${oldFilePath}`);
        } catch (err) {
          console.error(`Erro ao remover arquivo antigo: ${oldFilePath}`, err);
        }
      }
    });

    // 6. Mover o arquivo tempor√°rio para o destino final
    fs.copyFileSync(req.file.path, filePath);
    
    // Remover o arquivo tempor√°rio
    if (req.file.path !== filePath && fs.existsSync(req.file.path)) {
      fs.unlinkSync(req.file.path);
    }

    // 7. Atualizar o caminho no banco de dados
    await User.update(
      { foto_perfil: dbPath },
      { where: { id_utilizador: userId } }
    );

    // 8. Responder com sucesso
    return res.status(200).json({
      success: true,
      message: "Imagem de perfil atualizada com sucesso",
      path: dbPath
    });
    
  } catch (error) {
    console.error("Erro ao processar upload de imagem de perfil:", error);
    return res.status(500).json({
      success: false,
      message: "Erro ao processar a imagem de perfil",
      error: error.message
    });
  }
};

/**
 * Upload de imagem de capa - vers√£o simplificada com nome fixo
 */
const uploadImagemCapa = async (req, res) => {
  try {
    // 1. Verificar se a imagem foi enviada
    if (!req.file) {
      return res.status(400).json({ success: false, message: "Nenhuma imagem enviada" });
    }

    // 2. Verificar se o usu√°rio existe
    const userId = req.user.id_utilizador;
    const userEmail = req.user.email;
    
    if (!userId || !userEmail) {
      return res.status(401).json({ success: false, message: "Usu√°rio n√£o autenticado corretamente" });
    }

    // 3. Buscar o usu√°rio para garantir que existe
    const user = await User.findByPk(userId);
    if (!user) {
      return res.status(404).json({ success: false, message: "Usu√°rio n√£o encontrado" });
    }

    // 4. Preparar o diret√≥rio e caminho do arquivo
    const userSlug = userEmail.replace(/@/g, '_at_').replace(/\./g, '_');
    const userDir = path.join(uploadUtils.BASE_UPLOAD_DIR, 'users', userSlug);
    
    // Garantir que o diret√≥rio exista
    uploadUtils.ensureDir(userDir);
    
    // Nome fixo do arquivo (sem timestamp)
    const fileName = `${userEmail}_CAPA.png`;
    const filePath = path.join(userDir, fileName);
    
    // Caminho relativo para o banco de dados
    const dbPath = `uploads/users/${userSlug}/${fileName}`;

    // 5. Remover qualquer arquivo existente com mesmo nome base
    const files = fs.readdirSync(userDir);
    files.forEach(file => {
      // Encontrar TODOS os arquivos que correspondem ao padr√£o email_CAPA*.png
      if (file.startsWith(`${userEmail}_CAPA`) && file.endsWith('.png')) {
        const oldFilePath = path.join(userDir, file);
        try {
          fs.unlinkSync(oldFilePath);
          console.log(`Arquivo antigo removido: ${oldFilePath}`);
        } catch (err) {
          console.error(`Erro ao remover arquivo antigo: ${oldFilePath}`, err);
        }
      }
    });

    // 6. Mover o arquivo tempor√°rio para o destino final
    fs.copyFileSync(req.file.path, filePath);
    
    // Remover o arquivo tempor√°rio
    if (req.file.path !== filePath && fs.existsSync(req.file.path)) {
      fs.unlinkSync(req.file.path);
    }

    // 7. Atualizar o caminho no banco de dados
    await User.update(
      { foto_capa: dbPath },
      { where: { id_utilizador: userId } }
    );

    // 8. Responder com sucesso
    return res.status(200).json({
      success: true,
      message: "Imagem de capa atualizada com sucesso",
      path: dbPath
    });
    
  } catch (error) {
    console.error("Erro ao processar upload de imagem de capa:", error);
    return res.status(500).json({
      success: false,
      message: "Erro ao processar a imagem de capa",
      error: error.message
    });
  }
};








const deleteUser = async (req, res) => {
  try {
    const userId = req.params.id;
    
    // Verificar se o utilizador existe
    const user = await User.findByPk(userId);
    if (!user) {
      return res.status(404).json({ message: "Utilizador n√£o encontrado" });
    }
    
    // Verificar se √© um formador com cursos ativos
    if (user.id_cargo === 2) { // id_cargo 2 = Formador
      const cursosAtivos = await Curso.findAll({
        where: { 
          id_formador: userId,
          ativo: true
        }
      });
      
      if (cursosAtivos.length > 0) {
        return res.status(400).json({ 
          message: "N√£o √© poss√≠vel eliminar este formador pois possui cursos ativos",
          cursos: cursosAtivos
        });
      }
    }
    
    // Proceder com a exclus√£o (o delete cascade √© tratado no modelo)
    await user.destroy();
    
    return res.status(200).json({
      message: "Utilizador eliminado com sucesso"
    });
    
  } catch (error) {
    console.error("Erro ao eliminar utilizador:", error);
    return res.status(500).json({
      message: "Erro ao eliminar utilizador",
      error: error.message
    });
  }
};
























/**
 * FUN√á√ïES DE CONSULTA DE USU√ÅRIOS
 */

const getAllUsers = async (req, res) => {
  try {
    const users = await User.findAll();
    res.json(users);
  } catch (error) {
    res.status(500).json({ message: "Erro ao buscar utilizadores" });
  }
};

const getFormadores = async (req, res) => {
  try {
    const users = await User.findAll({ where: { id_cargo: 2 } });
    res.json(users);
  } catch (error) {
    res.status(500).json({ message: "Erro ao buscar formadores" });
  }
};

const getFormandos = async (req, res) => {
  try {
    const users = await User.findAll({ where: { id_cargo: 3 } });
    res.json(users);
  } catch (error) {
    res.status(500).json({ message: "Erro ao buscar formandos" });
  }
};

const getGestores = async (req, res) => {
  try {
    const users = await User.findAll({ where: { id_cargo: 1 } });
    res.json(users);
  } catch (error) {
    res.status(500).json({ message: "Erro ao buscar gestores" });
  }
};



module.exports = {

  getAllUsers,
  getFormadores,
  getFormandos,
  getGestores,

  createUser,
  deleteUser,
  loginUser,
  confirmAccount,
  resendConfirmation,
  verifyToken,

  perfilUser,
  changePassword,
  updatePerfilUser,

  uploadImagemPerfil,
  uploadImagemCapa,

  initDefaultUserImages
};